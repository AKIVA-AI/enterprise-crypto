import { serve } from "https://deno.land/std@0.168.0/http/server.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

// Trading copilot tools definition
const tradingTools = [
  {
    type: "function",
    function: {
      name: "analyze_market",
      description: "Analyze current market conditions for a specific instrument. Returns price, volume, trend, and sentiment data.",
      parameters: {
        type: "object",
        properties: {
          instrument: { type: "string", description: "Trading pair like BTC/USD, ETH/USD" },
          timeframe: { type: "string", enum: ["1h", "4h", "1d", "1w"], description: "Analysis timeframe" }
        },
        required: ["instrument"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "get_portfolio_status",
      description: "Get current portfolio positions, exposure, and P&L summary.",
      parameters: {
        type: "object",
        properties: {},
        required: []
      }
    }
  },
  {
    type: "function",
    function: {
      name: "check_risk_limits",
      description: "Check current risk metrics against configured limits.",
      parameters: {
        type: "object",
        properties: {
          book_id: { type: "string", description: "Optional book ID to check specific book" }
        },
        required: []
      }
    }
  },
  {
    type: "function",
    function: {
      name: "generate_trade_idea",
      description: "Generate a trade idea with entry, stop loss, and take profit levels.",
      parameters: {
        type: "object",
        properties: {
          instrument: { type: "string", description: "Trading pair" },
          direction: { type: "string", enum: ["long", "short"], description: "Trade direction" },
          risk_amount: { type: "number", description: "Amount willing to risk in USD" }
        },
        required: ["instrument", "direction"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "explain_strategy",
      description: "Explain how a specific trading strategy works and its current status.",
      parameters: {
        type: "object",
        properties: {
          strategy_name: { type: "string", description: "Strategy name like 'trend_following', 'mean_reversion', 'funding_arbitrage'" }
        },
        required: ["strategy_name"]
      }
    }
  },
  {
    type: "function",
    function: {
      name: "get_recent_signals",
      description: "Get recent trading signals generated by the system.",
      parameters: {
        type: "object",
        properties: {
          limit: { type: "number", description: "Number of signals to return (default 10)" },
          instrument: { type: "string", description: "Filter by instrument" }
        },
        required: []
      }
    }
  }
];

// Tool execution functions
async function executeToolCall(toolName: string, args: Record<string, unknown>): Promise<string> {
  console.log(`Executing tool: ${toolName} with args:`, args);
  
  switch (toolName) {
    case "analyze_market":
      return await analyzeMarket(args.instrument as string, args.timeframe as string);
    case "get_portfolio_status":
      return await getPortfolioStatus();
    case "check_risk_limits":
      return await checkRiskLimits(args.book_id as string | undefined);
    case "generate_trade_idea":
      return await generateTradeIdea(
        args.instrument as string,
        args.direction as string,
        args.risk_amount as number
      );
    case "explain_strategy":
      return await explainStrategy(args.strategy_name as string);
    case "get_recent_signals":
      return await getRecentSignals(args.limit as number, args.instrument as string);
    default:
      return JSON.stringify({ error: `Unknown tool: ${toolName}` });
  }
}

async function analyzeMarket(instrument: string, timeframe: string = "4h"): Promise<string> {
  // Simulated market analysis (would integrate with real data in production)
  const analyses: Record<string, object> = {
    "BTC/USD": {
      price: 98500,
      change_24h: 2.3,
      volume_24h: 45000000000,
      trend: "bullish",
      support: 95000,
      resistance: 102000,
      rsi: 62,
      sentiment: "positive",
      funding_rate: 0.0012,
      open_interest: 28000000000,
      recommendation: "Bullish momentum intact. Consider long positions on pullbacks to $96,000."
    },
    "ETH/USD": {
      price: 3850,
      change_24h: 1.8,
      volume_24h: 22000000000,
      trend: "bullish",
      support: 3700,
      resistance: 4000,
      rsi: 58,
      sentiment: "positive",
      funding_rate: 0.0008,
      open_interest: 12000000000,
      recommendation: "Following BTC strength. Break above $4,000 could trigger further upside."
    }
  };
  
  const data = analyses[instrument] || {
    price: Math.random() * 1000,
    change_24h: (Math.random() - 0.5) * 10,
    trend: Math.random() > 0.5 ? "bullish" : "bearish",
    recommendation: `Insufficient data for ${instrument}. Proceed with caution.`
  };
  
  return JSON.stringify({
    instrument,
    timeframe,
    analysis: data,
    generated_at: new Date().toISOString()
  });
}

async function getPortfolioStatus(): Promise<string> {
  // Simulated portfolio data
  return JSON.stringify({
    total_equity: 500000,
    available_balance: 350000,
    total_exposure: 150000,
    unrealized_pnl: 12500,
    realized_pnl_today: 3200,
    positions: [
      { instrument: "BTC/USD", side: "long", size_usd: 75000, entry: 96500, pnl: 8250, pnl_pct: 11 },
      { instrument: "ETH/USD", side: "long", size_usd: 45000, entry: 3750, pnl: 3200, pnl_pct: 7.1 },
      { instrument: "SOL/USD", side: "short", size_usd: 30000, entry: 185, pnl: 1050, pnl_pct: 3.5 }
    ],
    exposure_by_asset: {
      "BTC": "50%",
      "ETH": "30%",
      "SOL": "20%"
    },
    risk_metrics: {
      current_leverage: 0.43,
      max_drawdown_today: -1.2,
      sharpe_ratio_30d: 2.1
    }
  });
}

async function checkRiskLimits(bookId?: string): Promise<string> {
  return JSON.stringify({
    book_id: bookId || "all",
    limits: {
      max_position_size: { limit: 50000, current: 75000, status: "exceeded", action_required: true },
      max_leverage: { limit: 3.0, current: 0.43, status: "ok" },
      max_daily_loss: { limit: 10000, current: 0, status: "ok" },
      max_concentration: { limit: 25, current: 50, status: "exceeded", action_required: true },
      max_drawdown: { limit: 5, current: 1.2, status: "ok" }
    },
    warnings: [
      "BTC position exceeds max size limit by $25,000",
      "Portfolio concentration in BTC exceeds 25% limit"
    ],
    recommendations: [
      "Consider reducing BTC position by 50%",
      "Diversify into additional assets to reduce concentration"
    ]
  });
}

async function generateTradeIdea(
  instrument: string,
  direction: string,
  riskAmount: number = 1000
): Promise<string> {
  const prices: Record<string, number> = {
    "BTC/USD": 98500,
    "ETH/USD": 3850,
    "SOL/USD": 180
  };
  
  const currentPrice = prices[instrument] || 100;
  const isLong = direction === "long";
  
  const stopLossPct = 0.02; // 2%
  const takeProfitPct = 0.04; // 4% (2:1 R:R)
  
  const stopLoss = isLong 
    ? currentPrice * (1 - stopLossPct) 
    : currentPrice * (1 + stopLossPct);
  
  const takeProfit = isLong
    ? currentPrice * (1 + takeProfitPct)
    : currentPrice * (1 - takeProfitPct);
  
  const positionSize = riskAmount / stopLossPct;
  
  return JSON.stringify({
    trade_idea: {
      instrument,
      direction,
      entry_price: currentPrice,
      stop_loss: Math.round(stopLoss * 100) / 100,
      take_profit: Math.round(takeProfit * 100) / 100,
      position_size_usd: Math.round(positionSize),
      risk_amount: riskAmount,
      risk_reward_ratio: "1:2",
      max_loss: `-$${riskAmount}`,
      potential_profit: `+$${riskAmount * 2}`
    },
    rationale: `${direction.toUpperCase()} ${instrument} at ${currentPrice} with 2% stop and 4% target. Risk/reward of 1:2.`,
    confidence: 72,
    timeframe: "4h-1d"
  });
}

async function explainStrategy(strategyName: string): Promise<string> {
  const strategies: Record<string, object> = {
    "trend_following": {
      name: "Trend Following",
      description: "Identifies and follows established market trends using momentum indicators.",
      how_it_works: [
        "Calculates 20-period momentum using price change",
        "Enters long when momentum > 2% threshold",
        "Enters short when momentum < -2% threshold",
        "Position size scaled by confidence level"
      ],
      best_conditions: "Strong trending markets with clear directional moves",
      worst_conditions: "Choppy, range-bound markets",
      current_status: "Active",
      recent_performance: "+8.5% last 30 days",
      parameters: {
        lookback_periods: 20,
        momentum_threshold: "2%",
        confidence_multiplier: 1.5
      }
    },
    "mean_reversion": {
      name: "Mean Reversion",
      description: "Trades deviations from VWAP expecting price to revert to the mean.",
      how_it_works: [
        "Calculates deviation from Volume Weighted Average Price",
        "Sells when price is significantly above VWAP",
        "Buys when price is significantly below VWAP",
        "Uses 2 standard deviation threshold"
      ],
      best_conditions: "Range-bound markets with clear mean",
      worst_conditions: "Strong trending or breakout conditions",
      current_status: "Active",
      recent_performance: "+3.2% last 30 days",
      parameters: {
        lookback_periods: 50,
        std_threshold: 2.0,
        reversion_target: "50%"
      }
    },
    "funding_arbitrage": {
      name: "Funding Rate Arbitrage",
      description: "Captures funding rate payments in perpetual futures markets.",
      how_it_works: [
        "Monitors funding rates across venues",
        "Goes long when funding is positive (shorts pay longs)",
        "Goes short when funding is negative (longs pay shorts)",
        "Collects funding every 8 hours"
      ],
      best_conditions: "High funding rate environments",
      worst_conditions: "Low or neutral funding rates",
      current_status: "Active",
      recent_performance: "+1.8% last 30 days (low risk)",
      parameters: {
        min_spread: "0.1%",
        max_exposure: 50000
      }
    }
  };
  
  const strategy = strategies[strategyName];
  if (!strategy) {
    return JSON.stringify({
      error: `Unknown strategy: ${strategyName}`,
      available_strategies: Object.keys(strategies)
    });
  }
  
  return JSON.stringify(strategy);
}

async function getRecentSignals(limit: number = 10, instrument?: string): Promise<string> {
  const signals = [
    { id: "sig-001", instrument: "BTC/USD", direction: "buy", strategy: "trend_following", confidence: 78, price: 97500, time: "10 min ago", status: "executed" },
    { id: "sig-002", instrument: "ETH/USD", direction: "buy", strategy: "mean_reversion", confidence: 65, price: 3820, time: "25 min ago", status: "executed" },
    { id: "sig-003", instrument: "SOL/USD", direction: "sell", strategy: "trend_following", confidence: 72, price: 188, time: "1 hour ago", status: "rejected", reason: "concentration limit" },
    { id: "sig-004", instrument: "BTC/USD", direction: "buy", strategy: "funding_arbitrage", confidence: 75, price: 96800, time: "2 hours ago", status: "executed" },
    { id: "sig-005", instrument: "ETH/USD", direction: "sell", strategy: "mean_reversion", confidence: 58, price: 3890, time: "3 hours ago", status: "expired" }
  ];
  
  const filtered = instrument 
    ? signals.filter(s => s.instrument === instrument)
    : signals;
  
  return JSON.stringify({
    signals: filtered.slice(0, limit),
    total: filtered.length,
    summary: {
      executed: filtered.filter(s => s.status === "executed").length,
      rejected: filtered.filter(s => s.status === "rejected").length,
      expired: filtered.filter(s => s.status === "expired").length
    }
  });
}

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { messages, action } = await req.json();
    const LOVABLE_API_KEY = Deno.env.get("LOVABLE_API_KEY");
    
    if (!LOVABLE_API_KEY) {
      throw new Error("LOVABLE_API_KEY is not configured");
    }

    console.log("Trading copilot request:", { action, messageCount: messages?.length });

    // Build system prompt
    const systemPrompt = `You are an expert trading copilot for a professional crypto trading platform. You have access to real-time market data, portfolio information, risk metrics, and trading signals.

Your capabilities:
- Analyze market conditions for any trading pair
- Check portfolio status and P&L
- Monitor risk limits and flag issues
- Generate trade ideas with precise entry/exit levels
- Explain trading strategies in detail
- Review recent trading signals

Guidelines:
- Be concise but thorough in your analysis
- Always consider risk management
- Provide actionable insights
- Flag any risk limit breaches
- Use data from your tools to support recommendations
- Format numbers clearly (use $, %, etc.)

When asked about trades, always:
1. Check current market conditions
2. Review risk limits
3. Consider portfolio exposure
4. Provide specific price levels`;

    // Initial API call with tools
    const response = await fetch("https://ai.gateway.lovable.dev/v1/chat/completions", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${LOVABLE_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: "google/gemini-2.5-flash",
        messages: [
          { role: "system", content: systemPrompt },
          ...messages
        ],
        tools: tradingTools,
        tool_choice: "auto"
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error("AI gateway error:", response.status, errorText);
      
      if (response.status === 429) {
        return new Response(JSON.stringify({ error: "Rate limit exceeded. Please try again." }), {
          status: 429,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
      }
      if (response.status === 402) {
        return new Response(JSON.stringify({ error: "Usage limit reached. Please add credits." }), {
          status: 402,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
      }
      
      throw new Error(`AI gateway error: ${response.status}`);
    }

    let result = await response.json();
    let assistantMessage = result.choices[0].message;
    
    // Process tool calls if any
    const conversationMessages = [
      { role: "system", content: systemPrompt },
      ...messages
    ];

    // Agentic loop - keep processing tool calls
    while (assistantMessage.tool_calls && assistantMessage.tool_calls.length > 0) {
      console.log("Processing tool calls:", assistantMessage.tool_calls.length);
      
      // Add assistant message with tool calls
      conversationMessages.push(assistantMessage);
      
      // Execute each tool call
      for (const toolCall of assistantMessage.tool_calls) {
        const toolName = toolCall.function.name;
        const toolArgs = JSON.parse(toolCall.function.arguments || "{}");
        
        console.log(`Executing tool: ${toolName}`);
        const toolResult = await executeToolCall(toolName, toolArgs);
        
        // Add tool result to conversation
        conversationMessages.push({
          role: "tool",
          tool_call_id: toolCall.id,
          content: toolResult
        });
      }
      
      // Get next response
      const nextResponse = await fetch("https://ai.gateway.lovable.dev/v1/chat/completions", {
        method: "POST",
        headers: {
          Authorization: `Bearer ${LOVABLE_API_KEY}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          model: "google/gemini-2.5-flash",
          messages: conversationMessages,
          tools: tradingTools,
          tool_choice: "auto"
        }),
      });

      if (!nextResponse.ok) {
        throw new Error(`Follow-up AI call failed: ${nextResponse.status}`);
      }

      result = await nextResponse.json();
      assistantMessage = result.choices[0].message;
    }

    // Extract structured data from the response
    const responseData = {
      message: assistantMessage.content,
      tool_calls_made: conversationMessages
        .filter((m: { role: string }) => m.role === "tool")
        .map((m: { tool_call_id: string }) => m.tool_call_id),
      usage: result.usage
    };

    return new Response(JSON.stringify(responseData), {
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });

  } catch (error) {
    console.error("Trading copilot error:", error);
    return new Response(JSON.stringify({ 
      error: error instanceof Error ? error.message : "Unknown error" 
    }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});
